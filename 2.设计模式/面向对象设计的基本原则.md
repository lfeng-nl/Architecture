# 面向对象的设计原则

> [参考](https://www.jianshu.com/p/96f91d81c091)

## 1.单一职责原则 SRP

> 一个类, 只做好一件事, 并把这件事做好, 其只有一个引起它变化的原因.

- 将职责定义为引起变化的原因, 以调高内聚性来减少引起变化的原因.

## 2.开闭原则 OCP

> 模块是可扩展的, 而不可修改. **即软件应尽量在不修改原有代码的情况下进行扩展.**
>
> "可以通过穿不同的衣服来改变外貌, 但是不必为此改变自己的身体."

- **抽象化**是开闭原则的关键.
- 用抽象构建框架, 用实现扩展细节.
- 通过抽象类, 接口定义系统抽象层, 再通过具体类来进行扩展, 如果需要修改系统的行为, 无需对抽象层进行任何改动.

## 3.里氏替换原则 LSP

> 所有**引用基类对象的地方**能够透明地**使用其子类对象**

- 继承可以使子类拥有父类的方法和属性, 减少创建类的工作量, 提高了代码的重用性. 但是继承是侵入性的, 降低了代码的灵活性, 增加了耦合.当对父类代码修改时, 必须考虑到对子类产生的影响.
- 里氏替换原则可以对继承进行规则上的约束
    - 子类必须实现父类的抽象放方法, 但不得重写父类的非抽象方法;
    - 子类可以增加自己的特有方法;
- 在软件中将一个基类对象替换成它的子类对象, 程序将不会产生任何错误和异常.
- 由于使用基类对象的地方都可以使用子类对象, 因此在程序中尽量使用基类类型来对对象进行定义.

## 4.接口隔离原则 ISP

> **用户不应该被迫依赖他们不使用的接口**
>
> 把功能声明在接口中, 而不是类中;
>
> 使用多个专门的接口比使用单一的总接口要好.
>

- 尽量细化接口, 接口中的方法尽量少;

## 5.依赖倒置原则 DIP

> 高层模块不应该依赖于底层模块的实现, 而应该依赖于底层的抽象.
>
> 例如: 开关不应该依赖于电灯的开关实现, 而是应该依赖于一个抽象的开关标准接口;

- 核心: 面向接口编程

```java
/*
  张三是你的司机，负责开你的宝马.
*/
class Driver{
    void driveBMW();
}
/*
  但有一天你又买了辆奔驰，这下完蛋了，张三没有开奔驰的方法.
  显然你不能再招一个专门开奔驰的司机，或者说去修改张三的基因，让他会开奔驰.
*/
class Driver {
    void briveBMW();
    void driveBenz();
}
/*
  正确的做法是抽象出汽车对象，让宝马和奔驰实现汽车抽象。然后让Driver依赖汽车抽象。
  这样只要在出差前，注入相应的汽车，张三就可以开动了。即使以后你买了兰博基尼也不用去动张三。
*/
class Driver {
    Car car;
    void drive(){ this.car.run();}
}
```

- 

## 6.迪米特原则(最少知识原则)

> 一个软件实体应当尽可能少地与其他实体发生相互作用

- 尽量降低类与类之间的耦合, 尽量创建松耦合的类;
- 每一个类都应当尽量降低其成员变量和成员函数的访问权限.
- 尽量减少`public`;